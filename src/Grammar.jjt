/**
 * JJTree template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;
  LOOKAHEAD = 2;}PARSER_BEGIN(Grammar)import java.util.HashMap;
import java.lang.*; 
import java.util.*; 

public class Grammar{

  static HashMap<String, Map<String, Integer > > myMap = new HashMap<String, Map<String, Integer > >();

    public static void main(String args [])  {    System.out.println("Reading from standard input...");    System.out.print("Enter an expression like \"1+(2+3)*var;\" :");        try    {    
	  Grammar myYal = new Grammar(System.in);      SimpleNode root = myYal.Module();      root.dump("");      System.out.println("Accepted." + myYal.eval(root));    }    catch (Exception e)    {      System.out.println("Oops.");      System.out.println(e.getMessage());    }  }

  int eval(SimpleNode node)
  {
    if (node.jjtGetNumChildren() == 0)  // leaf node with integer value
    return node.val;
    else if (node.jjtGetNumChildren() == 1)  // only one child
    return this.eval((SimpleNode) node.jjtGetChild(0));
    SimpleNode lhs = (SimpleNode) node.jjtGetChild(0); //left child
    SimpleNode rhs = (SimpleNode) node.jjtGetChild(1); // right child
    switch (node.id)
    {
      case GrammarTreeConstants.JJTMODULE : System.out.println(".class public ");
      default : // abort
      System.out.println("Operador ilegal!");
      System.exit(1);
    }
    return 0;
  }}PARSER_END(Grammar)SKIP :{
" "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}
TOKEN : /* LITERALS */{

<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
| <ADDSUB_OP: "+" | "-">
| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
| <BITWISE_OP: "&" | "|" | "^">
| <NOT_OP: "!">
| <WHILE: "while">
| <IF: "if">
| <ELSE: "else">
| <ASSIGN: "=">
| <ASPA: "\"">
| <LPAR: "(">
| <RPAR: ")">
| <VIRG: ",">
| <PVIRG: ";">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <FUNCTION: "function">
| <MODULE: "module">
| <SIZE: "size">
}TOKEN : /* IDENTIFIERS */{

<INTEGER: (<DIGIT>)+>
| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
| <#DIGIT: ["0"-"9"]>
| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">}SimpleNode Module(): {Token t1;}
{
	<MODULE> t1=<ID>	/*{
	  System.out.println("Nome: "+ t1.image);	}
	{
      myMap.put(t1.image);
 	}*/

	 <LCHAVETA> (Declaration())* (Function())* <RCHAVETA>
	{
    return jjtThis;
    }
}void Declaration() #declaration: {}
{
	(ArrayElement() | ScalarElement())
	(<ASSIGN>(("["ArraySize()"]")
	|(<ADDSUB_OP>)?	<INTEGER>))? <PVIRG>
}
void Function() #function: {}
{
	((<FUNCTION>(ArrayElement()
				|ScalarElement()) <ASSIGN> <ID> <LPAR> (Varlist())? <RPAR>) 
	|
	(<FUNCTION> <ID> <LPAR>(Varlist())? <RPAR>))
	<LCHAVETA> Stmtlst() <RCHAVETA>
}

void Varlist(): {}
{
	(ArrayElement()
	|ScalarElement())
	(<VIRG> (ArrayElement()
			|ScalarElement()))*
}
void ArrayElement() #_arrayE: {}
{
	<ID> "[""]"
}
void ScalarElement() #_scalarE: {}
{
	<ID>
}
void Stmtlst() #stmtlst: {}
{
	(Stmt())*
}
void Stmt() #stmt: {}
{
	While()
	|If()
	|Assign()
	|Call() <PVIRG>
}
void Assign() #assign: {}
{
	Lhs() <ASSIGN> Rhs() <PVIRG>
}
void Lhs() #void: {}
{
	(ArrayAccess()
	|ScalarAccess())
}
void Rhs() #void: {}
{
	(Term() ((<ARITH_OP>
			 |<BITWISE_OP>
			 |<ADDSUB_OP>) Term())?)
	| "["ArraySize()"]"
}
void ArraySize() #aSize: {}
{
	(ScalarAccess()
	|<INTEGER>)
}
void Term() #void: {}
{
	(<ADDSUB_OP>)? (<INTEGER>
				   |Call()
				   |ArrayAccess()
				   |ScalarAccess())
}

void While(): {}
{
	<WHILE> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA>
}
void If(): {}
{
	<IF> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA> (<ELSE> <LCHAVETA> Stmtlst() <RCHAVETA>)?
}

void Exprtest() #void: {}
{
	<LPAR> Lhs() <RELA_OP> Rhs() <RPAR>
}
void Call() #void: {}
{
	<ID> ("." <ID>)? <LPAR> (ArgumentList())? <RPAR>
}
void ArgumentList() #void: {}
{
	Argument() (<VIRG> Argument())*
}
void Argument() #void: {}
{
	(<ID>
	|<STRING>
	|<INTEGER>)
}
void ArrayAccess() #AA: {}
{
	<ID> "[" Index() "]"
}

void ScalarAccess() #void: {}
{
	<ID>
}

void Index() #void: { Token t;}{   <ID> |

   t = <INTEGER>
   {
    jjtThis.val = Integer.parseInt(t.image);
   }#Inteiro
}


