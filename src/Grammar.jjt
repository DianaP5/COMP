/**
 * JJTree template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;
  LOOKAHEAD = 2;}PARSER_BEGIN(Grammar)
public class Grammar{  public static void main(String args [])  {    System.out.println("Reading from standard input...");    System.out.print("Enter an expression like \"1+(2+3)*var;\" :");    new Grammar(System.in);    try    {
      SimpleNode n = Grammar.Module();      n.dump("");      System.out.println("Accepted.");    }    catch (Exception e)    {      System.out.println("Oops.");      System.out.println(e.getMessage());    }  }}PARSER_END(Grammar)SKIP :{
" "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}
TOKEN : /* LITERALS */{

<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
| <ADDSUB_OP: "+" | "-">
| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
| <BITWISE_OP: "&" | "|" | "^">
| <NOT_OP: "!">
| <WHILE: "while">
| <IF: "if">
| <ELSE: "else">
| <ASSIGN: "=">
| <ASPA: "\"">
| <LPAR: "(">
| <RPAR: ")">
| <VIRG: ",">
| <PVIRG: ";">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <FUNCTION: "function">
| <MODULE: "module">
| <SIZE: "size">
}TOKEN : /* IDENTIFIERS */{

<INTEGER: (<DIGIT>)+>
| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
| <#DIGIT: ["0"-"9"]>
| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">}SimpleNode Module(): {}
{
	<MODULE> <ID> <LCHAVETA> (Declaration())* (Function())* <RCHAVETA>
	{
    return jjtThis;
    }
}void Declaration() #declaration: {}
{
	(ArrayElement() | ScalarElement())
	(<ASSIGN>(("["ArraySize()"]")
	|(<ADDSUB_OP>)?	<INTEGER>))? <PVIRG>
}
void Function() #function: {}
{
	((<FUNCTION>(ArrayElement()
				|ScalarElement()) <ASSIGN> <ID> <LPAR> (Varlist())? <RPAR>) 
	|
	(<FUNCTION> <ID> <LPAR>(Varlist())? <RPAR>))
	<LCHAVETA> Stmtlst() <RCHAVETA>
}

void Varlist(): {}
{
	(ArrayElement()
	|ScalarElement())
	(<VIRG> (ArrayElement()
			|ScalarElement()))*
}
void ArrayElement() #_arrayE: {}
{
	<ID> "[""]"
}
void ScalarElement() #_scalarE: {}
{
	<ID>
}
void Stmtlst() #stmtlst: {}
{
	(Stmt())*
}
void Stmt() #stmt: {}
{
	While()
	|If()
	|Assign()
	|Call() <PVIRG>
}
void Assign() #assign: {}
{
	Lhs() <ASSIGN> Rhs() <PVIRG>
}
void Lhs() #void: {}
{
	(ArrayAccess()
	|ScalarAccess())
}
void Rhs() #void: {}
{
	(Term() ((<ARITH_OP>
			 |<BITWISE_OP>
			 |<ADDSUB_OP>) Term())?)
	| "["ArraySize()"]"
}
void ArraySize() #aSize: {}
{
	(ScalarAccess()
	|<INTEGER>)
}
void Term() #void: {}
{
	(<ADDSUB_OP>)? (<INTEGER>
				   |Call()
				   |ArrayAccess()
				   |ScalarAccess())
}

void While(): {}
{
	<WHILE> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA>
}
void If(): {}
{
	<IF> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA> (<ELSE> <LCHAVETA> Stmtlst() <RCHAVETA>)?
}

void Exprtest() #void: {}
{
	<LPAR> Lhs() <RELA_OP> Rhs() <RPAR>
}
void Call() #void: {}
{
	<ID> ("." <ID>)? <LPAR> (ArgumentList())? <RPAR>
}
void ArgumentList() #void: {}
{
	Argument() (<VIRG> Argument())*
}
void Argument() #void: {}
{
	(<ID>
	|<STRING>
	|<INTEGER>)
}
void ArrayAccess() #void: {}
{
	<ID> "[" Index() "]"
}

void ScalarAccess() #void: {}
{
	<ID>
}

void Index() #void: {}{   <ID> | <INTEGER>
}


